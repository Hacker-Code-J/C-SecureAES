\chapter{AES - 128 / 192 / 256 (Byte Version)}

%\section{Overview of Advanced Encryption Standard}
\section{Specification}

\begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25} % Increase row height by 1.5 times
	\caption{Parameters of the Block Cipher AES}
	\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}c||cccccc}
		\toprule[1.2pt]
		\multirow{3}{*}{Algorithms} & Block & Key & Number of & Round-Key & Number of & Total Size of\\
		& Size & Length & Rounds &  Length & Round-Keys & Round-Keys \\
		& ($N_b$-byte) & ($N_k$-byte) & ($N_r$)& (byte) & ($N_r+1$)& ($N_b(N_r+1)$)\\
		\hline\hline
		AES-128 & 16 & 16 (128-bit) & 10 & 16 & 11 & 176 \\
		AES-192 & 16 & 24 (192-bit) & 12 & 16 & 13 & 208 \\
		AES-256 & 16 & 32 (256-bit) & 14 & 16 & 15 & 240 \\
		\bottomrule[1.2pt]
	\end{tabular*}
\end{table}

\begin{lstlisting}[style=C, caption={Configuration},captionpos=t]
// Define macros for AES key length
#define AES_VERSION 128 // Can be 128, 192, or 256
// Define macro for AES block size
#define AES_BLOCK_SIZE 16

// Define Nk and Nr based on AES key length
#if AES_VERSION == 128
	#define Nk 4
	#define Nr (Nk + 6) // 10
	#define ROUND_KEYS_SIZE (16 * (Nr + 1)) // 176
#elif AES_VERSION == 192
	#define Nk 6
	#define Nr (Nk + 6) // 12
	#define ROUND_KEYS_SIZE (16 * (Nr + 1)) // 208
#elif AES_VERSION == 256
	#define Nk 8
	#define Nr (Nk + 6) // 14
	#define ROUND_KEYS_SIZE (16 * (Nr + 1)) // 240
#else
	#error "Invalid AES ky length"
#endif
\end{lstlisting}


\newpage
\section{Key Expansion (General Version)}
\begin{algorithm}[H]
	\caption{Key Schedule (General Version)}
	
	\KwIn{User-key \( uk = (uk_0, \dots, uk_{N_k-1}) \) \( (uk_i \in \binaryfield^8) \)\tcp*{$uk$ is 16/24/32-byte}}
	\KwOut{Round-key \( \{rk_i\}_{i=0}^{4(N_r+1)-1} \) \( (rk_i \in \binaryfield^{32}) \)}
	\Comment{$\set{rk_i}_{i=0}^{4(N_r+1)-1}$ is 176/208/240-byte}
	\BlankLine
	$l\gets N_k/4$\tcp*{$l=4,6,8$}
	\For{$i=0$ \KwTo $l-1$}{
		$rk_i\gets uk_{4i}\parallel uk_{4i+1}\parallel uk_{4i+2}\parallel uk_{4i+3}$\;
	}
	\For{\( i = l \) \KwTo \( 4(N_r+1) -1 \)}{
		\( t \leftarrow rk_{i-1} \)\;
		\uIf{\( i \bmod l = 0 \)}{
			\( t \leftarrow \text{SubWord}\circ\text{RotWord}(t) \)\;
			\( t \leftarrow t \oplus (\texttt{rCon}_{i/l}\parallel\texttt{0x00}\parallel\texttt{0x00}\parallel\texttt{0x00}) \)\;
		}\uElseIf{\( l > 6\ \&\&\ i\bmod l = 4\)}{
			\( t \leftarrow \text{SubWord}(t) \)\;
		}\End
	
		\( rk_i \leftarrow rk_{i-l} \oplus_{32} t \)\;
	}
\end{algorithm}
\begin{lstlisting}[style=C, caption={Key Expansion (General ver.)},captionpos=t]
void KeyExpansion(const u8* uKey, u32* rKey) {
	u32 temp;
	
	for (int i = 0; i < Nk; i++) {
		rKey[i] = (u32)uKey[4*i] << 0x18 | 
				  (u32)uKey[4*i+1] << 0x10 | 
				  (u32)uKey[4*i+2] << 0x08 | 
				  (u32)uKey[4*i+3];
	}
	
	for (int i = Nk; i < (Nr + 1) * 4; i++) {
		temp = rKey[i - 1];
		if (i % Nk == 0) {
			temp = SubWord(RotWord(temp)) ^ rCon[i / Nk - 1];
		} else if (Nk > 6 && i % Nk == 4) {
			// Additional S-box transformation for AES-256
			temp = SubWord(temp);
		}
		rKey[i] = rKey[i - Nk] ^ temp;
	}
}
\end{lstlisting}

\newpage
\section{Advanced Encryption Standard - 128 / 192 / 256}

\begin{algorithm}[H]
	\caption{Encryption of AES}
	
	\KwIn{block $\mathsf{src} \in \binaryfield^{128}$, round-keys $\{rk_i\}_{i=0}^{N_r+1}$ ($rk_i \in \binaryfield^{128}$)}
	\KwOut{block $\mathsf{dst} \in \binaryfield^{128}$}
	\BlankLine
	$t \leftarrow \mathsf{src}$\;
	$t \leftarrow \text{AddRoundKey}(t, rk_0)$\;
	\For{$i \leftarrow 1$ \KwTo $N_r - 1$}{
		$t \leftarrow \text{SubBytes}(t)$\;
		$t \leftarrow \text{ShiftRows}(t)$\;
		$t \leftarrow \text{MixColumns}(t)$\;
		$t \leftarrow \text{AddRoundKey}(t, rk_i)$\;
	}
	$t \leftarrow \text{SubBytes}(t)$\;
	$t \leftarrow \text{ShiftRows}(t)$\;
	$t \leftarrow \text{AddRoundKey}(t, rk_{N_r})$\;
	$\mathsf{dst} \leftarrow t$\;
	\Return{$\mathsf{dst}$}\;
\end{algorithm}
\vspace{24pt}
\begin{algorithm}[H]
	\caption{Decryption of AES}
	
	\KwIn{block $\mathsf{src} \in \binaryfield^{128}$, round-keys $\{rk_i\}_{i=0}^{N_r+1}$ ($rk_i \in \binaryfield^{128}$)}
	\KwOut{block $\mathsf{dst} \in \binaryfield^{128}$}
	\BlankLine
	$t \leftarrow \mathsf{src}$\;
	$t \leftarrow \text{AddRoundKey}(t, rk_{N_r})$\;
	\For{$i \leftarrow N_r-1$ \KwTo $1$}{
		$t \leftarrow \text{InvShiftRows}(t)$\;
		$t \leftarrow \text{InvSubBytes}(t)$\;
		$t \leftarrow \text{AddRoundKey}(t, rk_i)$\;
		$t \leftarrow \text{InvMixColumns}(t)$\;
	}
	$t \leftarrow \text{InvSubBytes}(t)$\;
	$t \leftarrow \text{InvShiftRows}(t)$\;
	$t \leftarrow \text{AddRoundKey}(t, rk_{0})$\;
	$\mathsf{dst} \leftarrow t$\;
	\Return{$\mathsf{dst}$}\;
\end{algorithm}



\newpage

